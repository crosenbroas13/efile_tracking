"""Streamlit dashboard for inspecting inventory outputs."""
from __future__ import annotations

import sys

from io import BytesIO
from pathlib import Path
from typing import Dict, Optional

# Allow running via "streamlit run" without requiring an editable install.
REPO_ROOT = Path(__file__).resolve().parents[2]
if str(REPO_ROOT) not in sys.path:
    sys.path.insert(0, str(REPO_ROOT))

import pandas as pd
import plotly.express as px
import streamlit as st
from fpdf import FPDF

from src.io_utils import (
    format_run_label,
    list_inventory_candidates,
    load_inventory_df,
    load_run_log,
    pick_default_inventory,
)
from src.qa_metrics import IssueConfig, compute_executive_summary, counts_by_extension_and_mime, detect_potential_issues
from src.streamlit_config import get_output_dir

st.set_page_config(page_title="QA File Import", layout="wide")

CONFIG_DEFAULTS = {
    "large_file_threshold": 500,  # MB
}


def _load_selected_inventory(selected_path: Path | None) -> pd.DataFrame:
    if selected_path is None:
        return pd.DataFrame()
    return load_inventory_df(selected_path)


def _compute_error_count(run_logs: list[Dict]) -> int:
    if not run_logs:
        return 0
    latest = run_logs[0]
    return int(latest.get("errors_count", 0))


def _load_uploaded_inventory(uploaded_file) -> pd.DataFrame:
    """Parse an uploaded inventory.csv with safe dtypes."""

    dtype_overrides: Dict[str, str] = {
        "rel_path": "string",
        "abs_path": "string",
        "top_level_folder": "string",
        "extension": "string",
        "detected_mime": "string",
        "hash_value": "string",
        "sample_hash": "string",
    }

    buffer = BytesIO(uploaded_file.getbuffer())
    df = pd.read_csv(
        buffer,
        dtype=dtype_overrides,
        keep_default_na=False,
        dtype_backend="pyarrow",
        low_memory=False,
    )

    if "size_bytes" in df.columns:
        df["size_bytes"] = pd.to_numeric(df["size_bytes"], errors="coerce")

    return df


def _build_pdf_report(summary: Dict, folder_counts: pd.DataFrame, type_counts: pd.DataFrame, label: Optional[str]) -> bytes:
    """Create a lightweight PDF snapshot of the key metrics for sharing."""

    pdf = FPDF()
    pdf.add_page()
    pdf.set_font("Helvetica", "B", 16)
    pdf.cell(0, 10, "Dataset QA Summary", ln=True)

    pdf.set_font("Helvetica", "", 12)
    subtitle = label or "Selected inventory"
    pdf.multi_cell(0, 10, f"Inventory: {subtitle}")
    pdf.multi_cell(0, 8, "This PDF captures high-level totals without exposing file contents.")

    pdf.set_font("Helvetica", "B", 12)
    pdf.cell(0, 10, "Executive summary", ln=True)
    pdf.set_font("Helvetica", "", 12)
    pdf.cell(0, 8, f"Total files: {summary.get('total_files', 0):,}", ln=True)
    pdf.cell(0, 8, f"Total size: {summary.get('total_size_gb', 0):.2f} GB", ln=True)
    pdf.cell(0, 8, f"Logged errors: {summary.get('errors_count', 0)}", ln=True)

    if not folder_counts.empty:
        pdf.ln(4)
        pdf.set_font("Helvetica", "B", 12)
        pdf.cell(0, 10, "Top-level folder mix", ln=True)
        pdf.set_font("Helvetica", "", 12)
        for _, row in folder_counts.head(10).iterrows():
            pdf.cell(
                0,
                8,
                f"{row['top_level_folder']}: {row['files']} files ({row.get('percent_of_files', 0):.1f}% of total)",
                ln=True,
            )

    if not type_counts.empty:
        pdf.ln(4)
        pdf.set_font("Helvetica", "B", 12)
        pdf.cell(0, 10, "File types", ln=True)
        pdf.set_font("Helvetica", "", 12)
        for _, row in type_counts.head(10).iterrows():
            pdf.cell(0, 8, f".{row['extension']}: {row['count']} files", ln=True)

    pdf.ln(6)
    pdf.set_font("Helvetica", "I", 11)
    pdf.multi_cell(0, 8, "Generated by the QA dashboard for quick sharing.")

    return pdf.output(dest="S").encode("latin1")


def main() -> None:
    st.title("QA File Import")
    st.caption("Local-only dashboard that summarizes inventory outputs without reading file contents.")

    with st.sidebar:
        st.header("Navigation")
        page_selection = st.radio("Choose a page", ["Home", "QA File Import"])

    if page_selection == "Home":
        st.subheader("Welcome")
        st.markdown(
            """
            This home page is a landing spot for future tools. Use the navigation on the left to open the QA File Import view,
            where you can explore inventory outputs, see structure rollups, and export a portable PDF summary for
            non-technical reviewers.
            """
        )
        st.info("More pages can be added here as the toolkit grows.")
        return

    st.markdown("#### Choose an inventory to review")
    st.caption(
        "Your output folder is set on the Configuration page. You can still upload an inventory.csv directly "
        "from your computer if you need to review a different file. Controls here replace the former sidebar so "
        "everything stays in one view."
    )

    selector = st.container()
    with selector:
        input_cols = st.columns([2, 2, 1])
        with input_cols[0]:
            out_dir = get_output_dir()
            st.caption("Output folder (from Configuration page)")
            st.code(str(out_dir), language="text")
            st.page_link("pages/00_Configuration.py", label="Update output folder", icon="ðŸ§­")

            candidates = list_inventory_candidates(out_dir)
            options = {format_run_label(p): p for p in candidates}
            default_path = pick_default_inventory(out_dir)
            default_label = format_run_label(default_path) if default_path else None
            option_keys = list(options.keys())
            default_index = 0
            if default_label and default_label in option_keys:
                default_index = option_keys.index(default_label)
            selection = st.selectbox(
                "Inventory run (auto-detected from output folder)",
                options=option_keys or ["No inventory found"],
                index=default_index,
            )
            selected_path = options.get(selection)

        with input_cols[1]:
            uploaded_inventory = st.file_uploader(
                "Upload inventory.csv (optional)",
                type=["csv"],
                help="Start by selecting a folder above, then upload a CSV if you need to review a different file.",
            )
        with input_cols[2]:
            top_n = st.slider("Top rows for tables", min_value=5, max_value=50, value=20, step=5)

    filters = st.container()
    with filters:
        filter_cols = st.columns([1, 1])
        with filter_cols[0]:
            show_only_issues = st.checkbox("Highlight only potential issues", value=False)
        with filter_cols[1]:
            large_mb = st.number_input(
                "Very large file threshold (MB)",
                min_value=1,
                value=CONFIG_DEFAULTS["large_file_threshold"],
                step=50,
            )

    df: Optional[pd.DataFrame] = None
    current_label = None
    run_logs: list[Dict] = []

    if uploaded_inventory is not None:
        try:
            df = _load_uploaded_inventory(uploaded_inventory)
            current_label = uploaded_inventory.name
        except Exception as exc:  # pragma: no cover - user-driven input
            st.error(f"Unable to read uploaded file: {exc}")
            return
    elif selected_path:
        df = _load_selected_inventory(selected_path)
        current_label = selection
        run_logs = load_run_log(out_dir)

    if df is None or df.empty:
        st.warning("No inventory.csv found or the selected file is empty. Run the inventory pipeline first.")
        return

    errors_count = _compute_error_count(run_logs)

    issue_config = IssueConfig(large_file_threshold=int(large_mb * 1024 * 1024))
    issues_df = detect_potential_issues(df, issue_config)
    filtered_df = df
    if show_only_issues and not issues_df.empty:
        filtered_df = df[df["rel_path"].isin(issues_df["rel_path"])]

    st.markdown("### Executive Summary")
    st.caption("Quick health check for reviewers. Metrics update automatically as you filter or upload files.")
    summary = compute_executive_summary(filtered_df, errors_count=errors_count)
    metrics_cols = st.columns(3)
    metrics_cols[0].metric("Total files", f"{summary['total_files']:,}")
    metrics_cols[1].metric("Total size", f"{summary['total_size_gb']:.2f} GB")
    metrics_cols[2].metric("Logged errors", str(summary.get("errors_count", 0)))

    st.markdown("### Dataset Structure")
    st.caption("Understand where files live and which formats dominate your drop-off.")
    structure_cols = st.columns(2)

    with structure_cols[0]:
        st.subheader("Top-level folder rollup")
        folder_counts = (
            filtered_df.get("top_level_folder", pd.Series(dtype="string"))
            .fillna("Unknown")
            .value_counts()
            .reset_index()
        )
        folder_counts.columns = ["top_level_folder", "files"]
        if folder_counts.empty:
            st.info("No top-level folder information available.")
        else:
            folder_counts["percent_of_files"] = (folder_counts["files"] / folder_counts["files"].sum()) * 100
            pie_fig = px.pie(
                folder_counts,
                names="top_level_folder",
                values="files",
                title="Share of files by top-level folder",
                hole=0.3,
            )
            st.plotly_chart(pie_fig, use_container_width=True)
            st.dataframe(folder_counts)

    with structure_cols[1]:
        st.subheader("Files by type")
        type_counts = (
            filtered_df.get("extension", pd.Series(dtype="string"))
            .fillna("Unknown")
            .str.lower()
            .value_counts()
            .reset_index()
        )
        type_counts.columns = ["extension", "count"]
        if type_counts.empty:
            st.info("No file type information available.")
        else:
            top_types = type_counts.head(25)
            bar_fig = px.bar(top_types, x="extension", y="count", title="File count by extension")
            bar_fig.update_layout(xaxis_title="Extension", yaxis_title="Files")
            st.plotly_chart(bar_fig, use_container_width=True)
            st.dataframe(top_types)

    st.markdown("### File Type QA")
    st.caption("Spot unusual extensions and MIME combinations that may need closer review.")
    st.subheader("Counts by extension and MIME")
    counts_table = counts_by_extension_and_mime(filtered_df)
    st.dataframe(counts_table.head(top_n))

    st.markdown("### Run History")
    st.caption("Recent inventory runs help you connect this view back to the pipeline.")
    if run_logs:
        history_cols = ["timestamp", "root", "args", "runtime_seconds", "files_scanned", "errors_count", "git_commit"]
        history_df = pd.DataFrame(run_logs)[history_cols].head(10)
        st.dataframe(history_df)
        st.caption(f"Currently viewing: {current_label}")
    else:
        st.info("No run_log.jsonl entries found in this output folder.")

    st.markdown("### Export")
    st.caption("Create a PDF snapshot to share the summary without exposing file contents.")
    pdf_bytes = _build_pdf_report(summary, folder_counts if 'folder_counts' in locals() else pd.DataFrame(), type_counts if 'type_counts' in locals() else pd.DataFrame(), current_label)
    st.download_button(
        "Download PDF summary",
        data=pdf_bytes,
        file_name="qa_summary.pdf",
        mime="application/pdf",
    )


if __name__ == "__main__":
    main()
